module Prelude where
  type Show a = { show :: a -> Prim.String }
  type Read a = { read :: Prim.String -> a }
  type Ord a = { $greater$eq :: a -> a -> Prim.Boolean, $less$eq :: a -> a -> Prim.Boolean, $greater :: a -> a -> Prim.Boolean, $less :: a -> a -> Prim.Boolean }
  type Num a = { negate :: a -> a, $percent :: a -> a -> a, $div :: a -> a -> a, $times :: a -> a -> a, $minus :: a -> a -> a, $plus :: a -> a -> a }
  type Monad m = { $greater$greater$eq :: forall b. forall a. m a -> (a -> m b) -> m b, $$return :: forall a. a -> m a }
  type Functor f = { $less$dollar$greater :: forall b. forall a. (a -> b) -> f a -> f b }
  type Eq a = { $div$eq :: a -> a -> Prim.Boolean, $eq$eq :: a -> a -> Prim.Boolean }
  type Category a = { $greater$greater$greater :: forall d. forall c. forall b. a b c -> a c d -> a b d, $less$less$less :: forall d. forall c. forall b. a c d -> a b c -> a b d, id :: forall t. a t t }
  type BoolLike b = { not :: b -> b, $bar$bar :: b -> b -> b, $amp$amp :: b -> b -> b }
  type Bits b = { complement :: b -> b, zshr :: b -> Prim.Number -> b, shr :: b -> Prim.Number -> b, shl :: b -> Prim.Number -> b, $up :: b -> b -> b, $bar :: b -> b -> b, $amp :: b -> b -> b }
  type Applicative f = { $less$times$greater :: forall b. forall a. f (a -> b) -> f a -> f b, pure :: forall a. a -> f a }
  type Alternative f = { $less$bar$greater :: forall a. f a -> f a -> f a, empty :: forall a. f a }
  foreign import showString_show :: Prim.String -> Prim.String
  foreign import showString :: {  } -> Prelude.Show Prim.String
  foreign import showNumber_show :: Prim.Number -> Prim.String
  foreign import showNumber :: {  } -> Prelude.Show Prim.Number
  foreign import showBoolean_show :: Prim.Boolean -> Prim.String
  foreign import showBoolean :: {  } -> Prelude.Show Prim.Boolean
  foreign import readString_read :: Prim.String -> Prim.String
  foreign import readString :: {  } -> Prelude.Read Prim.String
  foreign import readNumber_read :: Prim.String -> Prim.Number
  foreign import readNumber :: {  } -> Prelude.Read Prim.Number
  foreign import readBoolean_read :: Prim.String -> Prim.Boolean
  foreign import readBoolean :: {  } -> Prelude.Read Prim.Boolean
  foreign import ordNumber_$less$eq :: Prim.Number -> Prim.Number -> Prim.Boolean
  foreign import ordNumber_$less :: Prim.Number -> Prim.Number -> Prim.Boolean
  foreign import ordNumber_$greater$eq :: Prim.Number -> Prim.Number -> Prim.Boolean
  foreign import ordNumber_$greater :: Prim.Number -> Prim.Number -> Prim.Boolean
  foreign import ordNumber :: {  } -> Prelude.Ord Prim.Number
  foreign import numNumber_negate :: Prim.Number -> Prim.Number
  foreign import numNumber_$times :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import numNumber_$plus :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import numNumber_$percent :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import numNumber_$minus :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import numNumber_$div :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import numNumber :: {  } -> Prelude.Num Prim.Number
  foreign import functorFromApplicative_$less$dollar$greater :: forall f. (Prelude.Applicative (f)) => forall b. forall a. (a -> b) -> f a -> f b
  foreign import functorFromApplicative :: forall f. Prelude.Applicative f -> Prelude.Functor f
  foreign import flip :: forall c. forall b. forall a. (a -> b -> c) -> b -> a -> c
  foreign import eqString_$eq$eq :: Prim.String -> Prim.String -> Prim.Boolean
  foreign import eqString_$div$eq :: Prim.String -> Prim.String -> Prim.Boolean
  foreign import eqString :: {  } -> Prelude.Eq Prim.String
  foreign import eqNumber_$eq$eq :: Prim.Number -> Prim.Number -> Prim.Boolean
  foreign import eqNumber_$div$eq :: Prim.Number -> Prim.Number -> Prim.Boolean
  foreign import eqNumber :: {  } -> Prelude.Eq Prim.Number
  foreign import eqBoolean_$eq$eq :: Prim.Boolean -> Prim.Boolean -> Prim.Boolean
  foreign import eqBoolean_$div$eq :: Prim.Boolean -> Prim.Boolean -> Prim.Boolean
  foreign import eqBoolean :: {  } -> Prelude.Eq Prim.Boolean
  foreign import const :: forall b. forall a. a -> b -> a
  foreign import categoryArr_id :: forall t. t -> t
  foreign import categoryArr_$less$less$less :: forall d. forall c. forall b. (c -> d) -> (b -> c) -> b -> d
  foreign import categoryArr_$greater$greater$greater :: forall d. forall c. forall b. (b -> c) -> (c -> d) -> b -> d
  foreign import categoryArr :: {  } -> Prelude.Category Prim.Function
  foreign import boolLikeBoolean_not :: Prim.Boolean -> Prim.Boolean
  foreign import boolLikeBoolean_$bar$bar :: Prim.Boolean -> Prim.Boolean -> Prim.Boolean
  foreign import boolLikeBoolean_$amp$amp :: Prim.Boolean -> Prim.Boolean -> Prim.Boolean
  foreign import boolLikeBoolean :: {  } -> Prelude.BoolLike Prim.Boolean
  foreign import eqArray_$eq$eq :: forall a. (Prelude.Eq (a)) => [a] -> [a] -> Prim.Boolean
  foreign import eqArray :: forall a. Prelude.Eq a -> Prelude.Eq [a]
  foreign import eqArray_$div$eq :: forall a. (Prelude.Eq (a)) => [a] -> [a] -> Prim.Boolean
  foreign import bitsNumber_zshr :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import bitsNumber_shr :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import bitsNumber_shl :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import bitsNumber_complement :: Prim.Number -> Prim.Number
  foreign import bitsNumber_$up :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import bitsNumber_$bar :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import bitsNumber_$amp :: Prim.Number -> Prim.Number -> Prim.Number
  foreign import bitsNumber :: {  } -> Prelude.Bits Prim.Number
  foreign import applicativeFromMonad_pure :: forall m. (Prelude.Monad (m)) => forall a. a -> m a
  foreign import applicativeFromMonad_$less$times$greater :: forall m. (Prelude.Monad (m)) => forall b. forall a. m (a -> b) -> m a -> m b
  foreign import applicativeFromMonad :: forall m. Prelude.Monad m -> Prelude.Applicative m
  foreign import ($) :: forall b. forall a. (a -> b) -> a -> b
  foreign import (#) :: forall b. forall a. a -> (a -> b) -> b
module Math where

module Global where

module Data.String.Regex where
  foreign import data Regex :: *
module Data.String where

module Data.Maybe where
  foreign import data Maybe :: * -> *
  foreign import showMaybe_show :: forall a. (Prelude.Show (a)) => Data.Maybe.Maybe a -> Prim.String
  foreign import showMaybe :: forall a. Prelude.Show a -> Prelude.Show (Data.Maybe.Maybe a)
  foreign import monadMaybe_$$return :: forall a. a -> Data.Maybe.Maybe a
  foreign import maybe :: forall b. forall a. b -> (a -> b) -> Data.Maybe.Maybe a -> b
  foreign import monadMaybe_$greater$greater$eq :: forall b. forall a. Data.Maybe.Maybe a -> (a -> Data.Maybe.Maybe b) -> Data.Maybe.Maybe b
  foreign import monadMaybe :: {  } -> Prelude.Monad Data.Maybe.Maybe
  foreign import functorMaybe_$less$dollar$greater :: forall b. forall a. (a -> b) -> Data.Maybe.Maybe a -> Data.Maybe.Maybe b
  foreign import functorMaybe :: {  } -> Prelude.Functor Data.Maybe.Maybe
  foreign import fromMaybe :: forall a. a -> Data.Maybe.Maybe a -> a
  foreign import applicativeMaybe_pure :: forall a. a -> Data.Maybe.Maybe a
  foreign import applicativeMaybe_$less$times$greater :: forall b. forall a. Data.Maybe.Maybe (a -> b) -> Data.Maybe.Maybe a -> Data.Maybe.Maybe b
  foreign import applicativeMaybe :: {  } -> Prelude.Applicative Data.Maybe.Maybe
module Data.Functor where
  type BiFunctor f = { $less$dollar$dollar$greater :: forall d. forall c. forall b. forall a. (a -> c) -> (b -> d) -> f a b -> f c d }
  foreign import second :: forall f. forall c. forall b. forall a. (Data.Functor.BiFunctor (f)) => (a -> c) -> f b a -> f b c
  foreign import first :: forall f. forall c. forall b. forall a. (Data.Functor.BiFunctor (f)) => (a -> b) -> f a c -> f b c
module Data.Eq where
  foreign import data Ref :: * -> *
  foreign import liftRef :: forall b. forall a. (a -> a -> b) -> Data.Eq.Ref a -> Data.Eq.Ref a -> b
  foreign import refEq :: forall a. Data.Eq.Ref a -> Data.Eq.Ref a -> Prim.Boolean
  foreign import refIneq :: forall a. Data.Eq.Ref a -> Data.Eq.Ref a -> Prim.Boolean
  foreign import eqRef_$eq$eq :: forall a. Data.Eq.Ref a -> Data.Eq.Ref a -> Prim.Boolean
  foreign import eqRef_$div$eq :: forall a. Data.Eq.Ref a -> Data.Eq.Ref a -> Prim.Boolean
  foreign import eqRef :: forall a. {  } -> Prelude.Eq (Data.Eq.Ref a)
module Data.Enum where
  type Enum a = { fromEnum :: a -> Prim.Number, toEnum :: Prim.Number -> Data.Maybe.Maybe a }
module Data.Either where
  foreign import data Either :: * -> * -> *
  foreign import showEither_show :: forall a. forall b. (Prelude.Show (a),Prelude.Show (b)) => Data.Either.Either a b -> Prim.String
  foreign import showEither :: forall a. forall b. Prelude.Show a -> Prelude.Show b -> Prelude.Show (Data.Either.Either a b)
  foreign import monadEither_$$return :: forall e. forall a. a -> Data.Either.Either e a
  foreign import functorEither_$less$dollar$greater :: forall a. forall b. forall a0. (a0 -> b) -> Data.Either.Either a a0 -> Data.Either.Either a b
  foreign import functorEither :: forall a. {  } -> Prelude.Functor (Data.Either.Either a)
  foreign import either :: forall c. forall b. forall a. (a -> c) -> (b -> c) -> Data.Either.Either a b -> c
  foreign import monadEither_$greater$greater$eq :: forall e. forall b. forall a. Data.Either.Either e a -> (a -> Data.Either.Either e b) -> Data.Either.Either e b
  foreign import monadEither :: forall e. {  } -> Prelude.Monad (Data.Either.Either e)
  foreign import applicativeEither_pure :: forall e. forall a. a -> Data.Either.Either e a
  foreign import applicativeEither_$less$times$greater :: forall e. forall b. forall a. Data.Either.Either e (a -> b) -> Data.Either.Either e a -> Data.Either.Either e b
  foreign import applicativeEither :: forall e. {  } -> Prelude.Applicative (Data.Either.Either e)
module Data.Array.Unsafe where
  foreign import tail :: forall a. [a] -> [a]
  foreign import head :: forall a. [a] -> a
module Data.Array where
  foreign import tail :: forall a. [a] -> Data.Maybe.Maybe [a]
  foreign import singleton :: forall a. a -> [a]
  foreign import monadArray_$$return :: forall a. a -> [a]
  foreign import isEmpty :: forall a. [a] -> Prim.Boolean
  foreign import head :: forall a. [a] -> Data.Maybe.Maybe a
  foreign import foldr :: forall b. forall a. (a -> b -> a) -> a -> [b] -> a
  foreign import foldl :: forall b. forall a. (b -> a -> b) -> b -> [a] -> b
  foreign import find :: forall a. (a -> Prim.Boolean) -> [a] -> Data.Maybe.Maybe a
  foreign import drop :: forall a. Prim.Number -> [a] -> [a]
  foreign import concatMap :: forall b. forall a. [a] -> (a -> [b]) -> [b]
  foreign import monadArray_$greater$greater$eq :: forall b. forall a. [a] -> (a -> [b]) -> [b]
  foreign import monadArray :: {  } -> Prelude.Monad Prim.Array
  foreign import any :: forall a. (a -> Prim.Boolean) -> [a] -> Prim.Boolean
  foreign import alternativeArray_empty :: forall a. [a]
  foreign import alternativeArray_$less$bar$greater :: forall a. [a] -> [a] -> [a]
  foreign import alternativeArray :: {  } -> Prelude.Alternative Prim.Array
  foreign import all :: forall a. (a -> Prim.Boolean) -> [a] -> Prim.Boolean
  foreign import (:) :: forall a. a -> [a] -> [a]
  foreign import filter :: forall a. (a -> Prim.Boolean) -> [a] -> [a]
  foreign import map :: forall b. forall a. (a -> b) -> [a] -> [b]
  foreign import functorArray_$less$dollar$greater :: forall b. forall a. (a -> b) -> [a] -> [b]
  foreign import functorArray :: {  } -> Prelude.Functor Prim.Array
  foreign import showArray_show :: forall a. (Prelude.Show (a)) => [a] -> Prim.String
  foreign import showArray :: forall a. Prelude.Show a -> Prelude.Show [a]
  foreign import range :: Prim.Number -> Prim.Number -> [Prim.Number]
  foreign import take :: forall a. Prim.Number -> [a] -> [a]
  foreign import zipWith :: forall c. forall b. forall a. (a -> b -> c) -> [a] -> [b] -> [c]
module Data.Monoid where
  type Monoid m = { $less$greater :: m -> m -> m, mempty :: m }
  foreign import monoidString_mempty :: Prim.String
  foreign import monoidString_$less$greater :: Prim.String -> Prim.String -> Prim.String
  foreign import monoidString :: {  } -> Data.Monoid.Monoid Prim.String
  foreign import monoidArray_mempty :: forall a. [a]
  foreign import monoidArray_$less$greater :: forall a. [a] -> [a] -> [a]
  foreign import monoidArray :: forall a. {  } -> Data.Monoid.Monoid [a]
  foreign import mconcat :: forall m. (Data.Monoid.Monoid (m)) => [m] -> m
module Data.Foldable where
  type Foldable f = { foldl :: forall b. forall a. (b -> a -> b) -> b -> f a -> b, foldr :: forall b. forall a. (a -> b -> b) -> b -> f a -> b }
  type BiFoldable f = { bifoldl :: forall c. forall b. forall a. (c -> a -> c) -> (c -> b -> c) -> c -> f a b -> c, bifoldr :: forall c. forall b. forall a. (a -> c -> c) -> (b -> c -> c) -> c -> f a b -> c }
  foreign import foldMap :: forall m. forall f. forall a. (Data.Foldable.Foldable (f),Data.Monoid.Monoid (m)) => (a -> m) -> f a -> m
module Data.Traversable where
  type Traversable t = { traverse :: forall f. forall b. forall a. (Prelude.Applicative (f)) => (a -> f b) -> t a -> f (t b) }
  type BiTraversable t = { bitraverse :: forall f. forall d. forall c. forall b. forall a. (Prelude.Applicative (f)) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d) }
  foreign import sequence :: forall t. forall f. forall a. (Prelude.Applicative (f),Data.Traversable.Traversable (t)) => t (f a) -> f (t a)
  foreign import bisequence :: forall t. forall f. forall b. forall a. (Prelude.Applicative (f),Data.Traversable.BiTraversable (t)) => t (f a) (f b) -> f (t a b)
module Data.Tuple where
  foreign import data Tuple :: * -> * -> *
  foreign import zip :: forall b. forall a. [a] -> [b] -> [Data.Tuple.Tuple a b]
  foreign import unzip :: forall b. forall a. [Data.Tuple.Tuple a b] -> Data.Tuple.Tuple [a] [b]
  foreign import uncurry :: forall c. forall b. forall a. (a -> b -> c) -> Data.Tuple.Tuple a b -> c
  foreign import showTuple_show :: forall a. forall b. (Prelude.Show (a),Prelude.Show (b)) => Data.Tuple.Tuple a b -> Prim.String
  foreign import showTuple :: forall a. forall b. Prelude.Show a -> Prelude.Show b -> Prelude.Show (Data.Tuple.Tuple a b)
  foreign import curry :: forall c. forall b. forall a. (Data.Tuple.Tuple a b -> c) -> a -> b -> c
module Control.Monad.Eff where
  foreign import data Eff :: # ! -> * -> *
  type Pure a = forall e. Control.Monad.Eff.Eff e a
  foreign import monadEff_$greater$greater$eq :: forall e. forall b. forall a. Control.Monad.Eff.Eff e a -> (a -> Control.Monad.Eff.Eff e b) -> Control.Monad.Eff.Eff e b
  foreign import monadEff_$$return :: forall e. forall a. a -> Control.Monad.Eff.Eff e a
  foreign import monadEff :: forall e. {  } -> Prelude.Monad (Control.Monad.Eff.Eff e)
module Control.Monad.Eff.Unsafe where

module Control.Monad.Error where
  foreign import data Error :: * -> !
module Control.Monad.ST where
  foreign import data ST :: * -> !
  foreign import data STRef :: * -> * -> *
  foreign import data STArray :: * -> * -> *
module Data.IORef where
  foreign import data Ref :: !
  foreign import data IORef :: * -> *
module Debug.Trace where
  foreign import data Trace :: !
  foreign import print :: forall r. forall a. (Prelude.Show (a)) => a -> Control.Monad.Eff.Eff (trace :: Debug.Trace.Trace | r) {  }
module Random where
  foreign import data Random :: !
module Control.Monad where
  foreign import when :: forall m. (Prelude.Monad (m)) => Prim.Boolean -> m {  } -> m {  }
  foreign import sequence :: forall a. forall m. (Prelude.Monad (m)) => [m a] -> m [a]
  foreign import zipWithM :: forall c. forall b. forall a. forall m. (Prelude.Monad (m)) => (a -> b -> m c) -> [a] -> [b] -> m [c]
  foreign import replicateM :: forall a. forall m. (Prelude.Monad (m)) => Prim.Number -> m a -> m [a]
  foreign import mapM :: forall b. forall a. forall m. (Prelude.Monad (m)) => (a -> m b) -> [a] -> m [b]
  foreign import join :: forall a. forall m. (Prelude.Monad (m)) => m (m a) -> m a
  foreign import foldM :: forall b. forall a. forall m. (Prelude.Monad (m)) => (a -> b -> m a) -> a -> [b] -> m a
  foreign import (>=>) :: forall c. forall b. forall a. forall m. (Prelude.Monad (m)) => (a -> m b) -> (b -> m c) -> a -> m c
  foreign import (<=<) :: forall c. forall b. forall a. forall m. (Prelude.Monad (m)) => (b -> m c) -> (a -> m b) -> a -> m c
module Algebra where
  type Semiring a = { $bar$times$times$bar :: a -> a -> a, $bar$times$bar :: a -> a -> a }
  type Semilattice a = { $bar$bslash$div$bar :: a -> a -> a }
  type Semigroup a = { $bar$plus$bar :: a -> a -> a }
  type Rng a = { $bar$minus$bar :: a -> a -> a }
  type Ring a = {  }
  type Rig a = { one :: a, zero :: a }
  type Monoid a = { ident :: a }
  type Lattice a = {  }
  type Group a = { inverse :: a -> a }
  type Field a = { $bar$div$bar :: a -> a -> a, recip :: a -> a }
  type DistributiveLattice a = {  }
  type ComplementedLattice a = { $bar$tilde$bar :: a -> a }
  type BoundedLattice a = { bottom :: a, top :: a }
  type BooleanAlgebra a = { $bar$bar$bar :: a -> a -> a, $bar$amp$bar :: a -> a -> a }
module Inquire where
  foreign import data WrapOp :: *
  foreign import data Rel :: *
  foreign import data JuncOp :: *
  foreign import data Inquire :: * -> * -> *
  foreign import traversableInquire :: forall k. {  } -> Data.Traversable.Traversable (Inquire.Inquire k)
  foreign import traversableInquire_traverse :: forall k. forall f. forall b. forall a. (Prelude.Applicative (f)) => (a -> f b) -> Inquire.Inquire k a -> f (Inquire.Inquire k b)
  foreign import showWrapOp_show :: Inquire.WrapOp -> Prim.String
  foreign import showWrapOp :: {  } -> Prelude.Show Inquire.WrapOp
  foreign import showRel_show :: Inquire.Rel -> Prim.String
  foreign import showRel :: {  } -> Prelude.Show Inquire.Rel
  foreign import showJuncOp_show :: Inquire.JuncOp -> Prim.String
  foreign import showJuncOp :: {  } -> Prelude.Show Inquire.JuncOp
  foreign import pred :: forall v. forall k. { val :: v, rel :: Inquire.Rel, key :: k } -> Inquire.Inquire k v
  foreign import neObj :: forall v. forall k. { val :: v, key :: k } -> Inquire.Inquire k v
  foreign import ne :: forall v. forall k. k -> v -> Inquire.Inquire k v
  foreign import monoidInquire_mempty :: forall k. forall v. Inquire.Inquire k v
  foreign import monoidInquire_$less$greater :: forall k. forall v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import monoidInquire :: forall k. forall v. {  } -> Data.Monoid.Monoid (Inquire.Inquire k v)
  foreign import ltObj :: forall v. forall k. { val :: v, key :: k } -> Inquire.Inquire k v
  foreign import lt :: forall v. forall k. k -> v -> Inquire.Inquire k v
  foreign import leObj :: forall v. forall k. { val :: v, key :: k } -> Inquire.Inquire k v
  foreign import le :: forall v. forall k. k -> v -> Inquire.Inquire k v
  foreign import gtObj :: forall v. forall k. { val :: v, key :: k } -> Inquire.Inquire k v
  foreign import gt :: forall v. forall k. k -> v -> Inquire.Inquire k v
  foreign import geObj :: forall v. forall k. { val :: v, key :: k } -> Inquire.Inquire k v
  foreign import ge :: forall v. forall k. k -> v -> Inquire.Inquire k v
  foreign import functorInquire :: forall k. {  } -> Prelude.Functor (Inquire.Inquire k)
  foreign import functorInquire_$less$dollar$greater :: forall k. forall b. forall a. (a -> b) -> Inquire.Inquire k a -> Inquire.Inquire k b
  foreign import foldableInquire :: forall k. {  } -> Data.Foldable.Foldable (Inquire.Inquire k)
  foreign import foldableInquire_foldr :: forall k. forall b. forall a. (a -> b -> b) -> b -> Inquire.Inquire k a -> b
  foreign import foldableInquire_foldl :: forall k. forall b. forall a. (b -> a -> b) -> b -> Inquire.Inquire k a -> b
  foreign import eqWrapOp_$eq$eq :: Inquire.WrapOp -> Inquire.WrapOp -> Prim.Boolean
  foreign import eqWrapOp :: {  } -> Prelude.Eq Inquire.WrapOp
  foreign import eqWrapOp_$div$eq :: Inquire.WrapOp -> Inquire.WrapOp -> Prim.Boolean
  foreign import eqRel_$eq$eq :: Inquire.Rel -> Inquire.Rel -> Prim.Boolean
  foreign import eqRel :: {  } -> Prelude.Eq Inquire.Rel
  foreign import eqRel_$div$eq :: Inquire.Rel -> Inquire.Rel -> Prim.Boolean
  foreign import eqObj :: forall v. forall k. { val :: v, key :: k } -> Inquire.Inquire k v
  foreign import eqJuncOp_$eq$eq :: Inquire.JuncOp -> Inquire.JuncOp -> Prim.Boolean
  foreign import eqJuncOp :: {  } -> Prelude.Eq Inquire.JuncOp
  foreign import eqJuncOp_$div$eq :: Inquire.JuncOp -> Inquire.JuncOp -> Prim.Boolean
  foreign import showInquire_show :: forall k. forall v. (Prelude.Show (k),Prelude.Show (v)) => Inquire.Inquire k v -> Prim.String
  foreign import showInquire :: forall k. forall v. Prelude.Show k -> Prelude.Show v -> Prelude.Show (Inquire.Inquire k v)
  foreign import gen :: forall v. forall k. (Prelude.Show (k),Prelude.Show (v)) => Inquire.Inquire k v -> Prim.String
  foreign import eqInquire :: forall k. forall v. Prelude.Eq k -> Prelude.Eq v -> Prelude.Eq (Inquire.Inquire k v)
  foreign import eqInquire_$eq$eq :: forall k. forall v. (Prelude.Eq (k),Prelude.Eq (v)) => Inquire.Inquire k v -> Inquire.Inquire k v -> Prim.Boolean
  foreign import eqInquire_$div$eq :: forall k. forall v. (Prelude.Eq (k),Prelude.Eq (v)) => Inquire.Inquire k v -> Inquire.Inquire k v -> Prim.Boolean
  foreign import idempotent :: forall v. forall k. (Prelude.Eq (k),Prelude.Eq (v)) => Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import eq :: forall v. forall k. k -> v -> Inquire.Inquire k v
  foreign import complementedLatticeInquire_$bar$tilde$bar :: forall k. forall v. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import complementedLatticeInquire :: forall k. forall v. {  } -> Algebra.ComplementedLattice (Inquire.Inquire k v)
  foreign import neg :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import booleanAlgebraInquire_$bar$bar$bar :: forall k. forall v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import booleanAlgebraInquire_$bar$amp$bar :: forall k. forall v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import booleanAlgebraInquire :: forall k. forall v. {  } -> Algebra.BooleanAlgebra (Inquire.Inquire k v)
  foreign import codistribute :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import commute :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import distribute :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import equiv :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import implies :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import or :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import xor :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import bitraversableInquire :: {  } -> Data.Traversable.BiTraversable Inquire.Inquire
  foreign import bitraversableInquire_bitraverse :: forall f. forall d. forall c. forall b. forall a. (Prelude.Applicative (f)) => (a -> f c) -> (b -> f d) -> Inquire.Inquire a b -> f (Inquire.Inquire c d)
  foreign import biFunctorInquire :: {  } -> Data.Functor.BiFunctor Inquire.Inquire
  foreign import biFunctorInquire_$less$dollar$dollar$greater :: forall d. forall c. forall b. forall a. (a -> c) -> (b -> d) -> Inquire.Inquire a b -> Inquire.Inquire c d
  foreign import biFoldableInquire :: {  } -> Data.Foldable.BiFoldable Inquire.Inquire
  foreign import biFoldableInquire_bifoldr :: forall c. forall b. forall a. (a -> c -> c) -> (b -> c -> c) -> c -> Inquire.Inquire a b -> c
  foreign import biFoldableInquire_bifoldl :: forall c. forall b. forall a. (c -> a -> c) -> (c -> b -> c) -> c -> Inquire.Inquire a b -> c
  foreign import associate :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import assocRight :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import assocLeft :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import and :: forall v. forall k. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import absorb :: forall v. forall k. (Prelude.Eq (k),Prelude.Eq (v)) => Inquire.Inquire k v -> Inquire.Inquire k v
module Inquire.Combinators where
  foreign import toObj :: forall v. forall k. Inquire.Inquire k v -> { vals :: [v], keys :: [k] }
  foreign import vals :: forall v. forall k. Inquire.Inquire k v -> [v]
  foreign import remove' :: forall v. forall k. (Prelude.Eq (k),Prelude.Eq (v)) => (Inquire.Inquire k v -> Inquire.Inquire k v -> Prim.Boolean) -> Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import removeAll :: forall v. forall k. (Prelude.Eq (k),Prelude.Eq (v)) => Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import remove :: forall v. forall k. (Prelude.Eq (k),Prelude.Eq (v)) => Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
  foreign import keys :: forall v. forall k. Inquire.Inquire k v -> [k]
  foreign import toArrayObj :: forall v. forall k. Inquire.Inquire k v -> [{ val :: v, key :: k }]
  foreign import toArrayPair :: forall t4360. Inquire.Inquire t4360 t4360 -> [[t4360]]
  foreign import toTuple :: forall v. forall k. Inquire.Inquire k v -> [Data.Tuple.Tuple k v]
  foreign import fromArrayPair :: forall t4383. [[t4383]] -> Inquire.Inquire t4383 t4383
  foreign import fromArrayObj :: forall v. forall k. [{ val :: v, key :: k }] -> Inquire.Inquire k v
  foreign import find :: forall v. forall k. (Prelude.Eq (v)) => v -> Inquire.Inquire k v -> Data.Maybe.Maybe (Inquire.Inquire k v)
  foreign import filterVals :: forall v. forall k. (v -> Prim.Boolean) -> Inquire.Inquire k v -> Inquire.Inquire k v
module Inquire.Zipper where
  foreign import data Context :: * -> * -> *
  foreign import data InquireZ :: * -> * -> *
  type Movement k v = Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
  foreign import zipUp :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
  foreign import zipRight :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
  foreign import zipMost :: forall v. forall k. Inquire.Zipper.Movement k v -> Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
  foreign import zipRightmost :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
  foreign import zipUpmost :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
  foreign import zipLeft :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
  foreign import zipLeftmost :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
  foreign import zipDown :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
  foreign import toInquireZ :: forall v. forall k. Inquire.Inquire k v -> Inquire.Zipper.InquireZ k v
  foreign import modify :: forall v. forall k. (Inquire.Inquire k v -> Inquire.Inquire k v) -> Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
  foreign import getHole :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Inquire.Inquire k v
  foreign import query :: forall v. forall k. forall a. (Inquire.Inquire k v -> a) -> Inquire.Zipper.InquireZ k v -> a
  foreign import fromInquireZ :: forall v. forall k. Inquire.Zipper.InquireZ k v -> Inquire.Inquire k v