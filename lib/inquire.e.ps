module Text.Parsing.Read where
module Prelude where
foreign import (#) :: forall a b. a -> (a -> b) -> b
foreign import ($) :: forall a b. (a -> b) -> a -> b
foreign import const :: forall a b. a -> b -> a
foreign import flip :: forall a b c. (a -> b -> c) -> b -> a -> c
module Math where
module Global where
foreign import decodeURI :: Prim.String -> Prim.String
foreign import decodeURIComponent :: Prim.String -> Prim.String
foreign import encodeURI :: Prim.String -> Prim.String
foreign import encodeURIComponent :: Prim.String -> Prim.String
foreign import isFinite :: Prim.Number -> Prim.Boolean
foreign import isNaN :: Prim.Number -> Prim.Boolean
foreign import parseFloat :: Prim.String -> Prim.Number
foreign import parseInt :: Prim.String -> Prim.Number
module Data.String.Regex where
foreign import data Regex :: *
module Data.String where
module Data.Maybe where
foreign import data Maybe :: * -> *
foreign import fromMaybe :: forall a. a -> Data.Maybe.Maybe a -> a
foreign import maybe :: forall a b. b -> (a -> b) -> Data.Maybe.Maybe a -> b
module Data.Functor where
foreign import bimap :: forall a b c d f. (Data.Functor.BiFunctor f) => (a -> c) -> (b -> d) -> f a b -> f c d
foreign import first :: forall a b c f. (Data.Functor.BiFunctor f) => (a -> b) -> f a c -> f b c
foreign import map :: forall a b f. (Prelude.Functor f) => (a -> b) -> f a -> f b
foreign import second :: forall a b c f. (Data.Functor.BiFunctor f) => (a -> c) -> f b a -> f b c
module Data.Eq where
foreign import data Ref :: * -> *
foreign import liftRef :: forall a b. (a -> a -> b) -> Data.Eq.Ref a -> Data.Eq.Ref a -> b
foreign import refEq :: forall a. Data.Eq.Ref a -> Data.Eq.Ref a -> Prim.Boolean
foreign import refIneq :: forall a. Data.Eq.Ref a -> Data.Eq.Ref a -> Prim.Boolean
module Data.Enum where
module Data.Either where
foreign import data Either :: * -> * -> *
foreign import either :: forall a b c. (a -> c) -> (b -> c) -> Data.Either.Either a b -> c
module Data.Array.Unsafe where
foreign import head :: forall a. [a] -> a
foreign import tail :: forall a. [a] -> [a]
module Data.Array where
foreign import (:) :: forall a. a -> [a] -> [a]
foreign import all :: forall a. (a -> Prim.Boolean) -> [a] -> Prim.Boolean
foreign import any :: forall a. (a -> Prim.Boolean) -> [a] -> Prim.Boolean
foreign import concatMap :: forall a b. [a] -> (a -> [b]) -> [b]
foreign import drop :: forall a. Prim.Number -> [a] -> [a]
foreign import filter :: forall a. (a -> Prim.Boolean) -> [a] -> [a]
foreign import find :: forall a. (a -> Prim.Boolean) -> [a] -> Data.Maybe.Maybe a
foreign import foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b
foreign import foldr :: forall a b. (a -> b -> a) -> a -> [b] -> a
foreign import head :: forall a. [a] -> Data.Maybe.Maybe a
foreign import isEmpty :: forall a. [a] -> Prim.Boolean
foreign import map :: forall a b. (a -> b) -> [a] -> [b]
foreign import range :: Prim.Number -> Prim.Number -> [Prim.Number]
foreign import singleton :: forall a. a -> [a]
foreign import tail :: forall a. [a] -> Data.Maybe.Maybe [a]
foreign import take :: forall a. Prim.Number -> [a] -> [a]
foreign import zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
module Data.Monoid where
foreign import mconcat :: forall m. (Data.Monoid.Monoid m) => [m] -> m
module Data.Foldable where
foreign import foldMap :: forall a f m. (Data.Foldable.Foldable f, Data.Monoid.Monoid m) => (a -> m) -> f a -> m
module Data.Traversable where
foreign import bisequence :: forall a b f t. (Prelude.Applicative f, Data.Traversable.BiTraversable t) => t (f a) (f b) -> f (t a b)
foreign import sequence :: forall a f t. (Prelude.Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
module Inquire where
foreign import data Inquire :: * -> * -> *
foreign import data JuncOp :: *
foreign import data Rel :: *
foreign import data WrapOp :: *
foreign import absorb :: forall k v. (Prelude.Eq k, Prelude.Eq v) => Inquire.Inquire k v -> Inquire.Inquire k v
foreign import and :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import assocLeft :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import assocRight :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import associate :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import codistribute :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import commute :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import distribute :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import eq :: forall k v. k -> v -> Inquire.Inquire k v
foreign import eqObj :: forall k v. { val :: v, key :: k } -> Inquire.Inquire k v
foreign import equiv :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import ge :: forall k v. k -> v -> Inquire.Inquire k v
foreign import geObj :: forall k v. { val :: v, key :: k } -> Inquire.Inquire k v
foreign import gen :: forall k v. (Prelude.Show k, Prelude.Show v) => Inquire.Inquire k v -> Prim.String
foreign import gt :: forall k v. k -> v -> Inquire.Inquire k v
foreign import gtObj :: forall k v. { val :: v, key :: k } -> Inquire.Inquire k v
foreign import idempotent :: forall k v. (Prelude.Eq k, Prelude.Eq v) => Inquire.Inquire k v -> Inquire.Inquire k v
foreign import implies :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import le :: forall k v. k -> v -> Inquire.Inquire k v
foreign import leObj :: forall k v. { val :: v, key :: k } -> Inquire.Inquire k v
foreign import lt :: forall k v. k -> v -> Inquire.Inquire k v
foreign import ltObj :: forall k v. { val :: v, key :: k } -> Inquire.Inquire k v
foreign import ne :: forall k v. k -> v -> Inquire.Inquire k v
foreign import neObj :: forall k v. { val :: v, key :: k } -> Inquire.Inquire k v
foreign import neg :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v
foreign import or :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import xor :: forall k v. Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
module Data.Tuple where
foreign import data Tuple :: * -> * -> *
foreign import curry :: forall a b c. (Data.Tuple.Tuple a b -> c) -> a -> b -> c
foreign import uncurry :: forall a b c. (a -> b -> c) -> Data.Tuple.Tuple a b -> c
foreign import unzip :: forall a b. [Data.Tuple.Tuple a b] -> Data.Tuple.Tuple [a] [b]
foreign import zip :: forall a b. [a] -> [b] -> [Data.Tuple.Tuple a b]
module Inquire.Combinators where
foreign import filterByKey :: forall k v. (k -> Prim.Boolean) -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import filterByVal :: forall k v. (v -> Prim.Boolean) -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import findByKey :: forall k v. (Prelude.Eq k) => k -> Inquire.Inquire k v -> Data.Maybe.Maybe (Inquire.Inquire k v)
foreign import findByVal :: forall k v. (Prelude.Eq v) => v -> Inquire.Inquire k v -> Data.Maybe.Maybe (Inquire.Inquire k v)
foreign import fromArrayObj :: forall k v. [{ val :: v, key :: k }] -> Inquire.Inquire k v
foreign import fromArrayPair :: forall t3921. [[t3921]] -> Inquire.Inquire t3921 t3921
foreign import keys :: forall k v. Inquire.Inquire k v -> [k]
foreign import remove :: forall k v. (Prelude.Eq k, Prelude.Eq v) => Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import removeAll :: forall k v. (Prelude.Eq k, Prelude.Eq v) => Inquire.Inquire k v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import replaceValByKey :: forall k v. (Prelude.Eq k) => v -> k -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import replaceValByVal :: forall k v. (Prelude.Eq v) => v -> v -> Inquire.Inquire k v -> Inquire.Inquire k v
foreign import toArrayObj :: forall k v. Inquire.Inquire k v -> [{ val :: v, key :: k }]
foreign import toArrayPair :: forall t3898. Inquire.Inquire t3898 t3898 -> [[t3898]]
foreign import toObj :: forall k v. Inquire.Inquire k v -> { vals :: [v], keys :: [k] }
foreign import toTuple :: forall k v. Inquire.Inquire k v -> [Data.Tuple.Tuple k v]
foreign import vals :: forall k v. Inquire.Inquire k v -> [v]
module Inquire.Zipper where
foreign import data InquireZ :: * -> * -> *
foreign import fromInquireZ :: forall k v. Inquire.Zipper.InquireZ k v -> Inquire.Inquire k v
foreign import getHole :: forall k v. Inquire.Zipper.InquireZ k v -> Inquire.Inquire k v
foreign import modify :: forall k v. (Inquire.Inquire k v -> Inquire.Inquire k v) -> Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
foreign import query :: forall a k v. (Inquire.Inquire k v -> a) -> Inquire.Zipper.InquireZ k v -> a
foreign import toInquireZ :: forall k v. Inquire.Inquire k v -> Inquire.Zipper.InquireZ k v
foreign import zipDown :: forall k v. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
foreign import zipLeft :: forall k v. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
foreign import zipLeftmost :: forall k v. Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
foreign import zipMost :: forall k v. Inquire.Zipper.Movement k v -> Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
foreign import zipRight :: forall k v. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
foreign import zipRightmost :: forall k v. Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
foreign import zipUp :: forall k v. Inquire.Zipper.InquireZ k v -> Data.Maybe.Maybe (Inquire.Zipper.InquireZ k v)
foreign import zipUpmost :: forall k v. Inquire.Zipper.InquireZ k v -> Inquire.Zipper.InquireZ k v
module Control.Monad.Eff where
foreign import data Eff :: # ! -> * -> *
foreign import data Pure :: * -> *
module Control.Monad.Eff.Unsafe where
module Control.Monad.Error where
foreign import data Error :: * -> !
module Control.Monad.ST where
foreign import data ST :: * -> !
foreign import data STArray :: * -> * -> *
foreign import data STRef :: * -> * -> *
module Data.IORef where
foreign import data IORef :: * -> *
foreign import data Ref :: !
module Debug.Trace where
foreign import data Trace :: !
foreign import print :: forall a r. (Prelude.Show a) => a -> Control.Monad.Eff.Eff (trace :: Debug.Trace.Trace | r) {  }
module Random where
foreign import data Random :: !
module Control.Monad where
foreign import (<=<) :: forall m a b c. (Prelude.Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
foreign import (>=>) :: forall m a b c. (Prelude.Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
foreign import foldM :: forall m a b. (Prelude.Monad m) => (a -> b -> m a) -> a -> [b] -> m a
foreign import join :: forall m a. (Prelude.Monad m) => m (m a) -> m a
foreign import mapM :: forall m a b. (Prelude.Monad m) => (a -> m b) -> [a] -> m [b]
foreign import replicateM :: forall m a. (Prelude.Monad m) => Prim.Number -> m a -> m [a]
foreign import sequence :: forall m a. (Prelude.Monad m) => [m a] -> m [a]
foreign import when :: forall m. (Prelude.Monad m) => Prim.Boolean -> m {  } -> m {  }
foreign import zipWithM :: forall m a b c. (Prelude.Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
module Algebra where