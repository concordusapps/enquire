{"name":"Inquire.js","tagline":"Generate advanced query strings. ","body":"# Inquire\r\n[![Build Status](https://travis-ci.org/concordusapps/inquire.js.png?branch=master)](https://travis-ci.org/concordusapps/inquire.js)\r\n[![Coverage Status](https://coveralls.io/repos/concordusapps/inquire.js/badge.png?branch=master)](https://coveralls.io/r/concordusapps/inquire.js?branch=master)\r\n[![devDependency Status](https://david-dm.org/concordusapps/inquire.js/dev-status.png)](https://david-dm.org/concordusapps/inquire.js#info=devDependencies)\r\n\r\nInquire allows you to generate advanced query strings.\r\nCurrently supports [armet][armet] syntax query strings.\r\n\r\n### Fantasy Land Compliant\r\n[![Fantasy Land](images/fantasy-land.png)](https://github.com/puffnfresh/fantasy-land)\r\n\r\n#### Algebras\r\n* Semigroup\r\n* Monoid\r\n* Functor\r\n\r\n## Installation\r\n\r\nInquire is available on the npm registry: [inquire][inquire]\r\n\r\nYou can install it with npm.\r\n\r\n    npm install inquire\r\n\r\nRun the tests.\r\n\r\n    npm test\r\n\r\nCheck the coverage.\r\n\r\n    npm run cover\r\n\r\n## The Problem\r\n\r\nCurrently, query strings only conjoin predicates together with equality.\r\n[Armet][armet] attempts to extend this in two ways:\r\n\r\n* Allowing predicates to be conjoined, disjoined and negated.\r\n* Allowing more than just equality, e.g. inequalities.\r\n\r\nThis ends up creating a problem.\r\nWe now have to generate these advanced query strings.\r\nGenerating these advanced query strings by hand gets unwieldy.\r\n\r\nFor example, let's say we are dealing with a REST api for shapes.\r\nWe can `GET` on `/api/shape` and return all of the shapes.\r\n\r\nNow let's try to get more detailed in our result.\r\nLet's say we want red shapes wider than 30 pixels or\r\nwe want all shapes with no more than 12 sides or\r\nwe want all of the squares that either aren't black or that were created by bob.\r\nOur `GET` request becomes:\r\n\r\n`/api/shape?(color=red&width>30);sides<=12;(shape=square&(color!=black;user=bob))`\r\n\r\n\r\n## A Solution\r\n\r\nWe need a better way to generate query strings for [armet][armet]'s consumption.\r\nInquire allows you do the same query without trying to man-handle the string.\r\n\r\nLiveScript:\r\n\r\n```livescript\r\nquery = inquire(inquire \\color, \\red .and inquire.gt \\width, 30)\r\n.or inquire.lte \\sides, 12\r\n.or (inquire \\shape, \\square .and (inquire.neq \\color, \\black .or \\user, \\bob))\r\nurl = \"/api/shape/#{query.generate!}\"\r\n# url => /api/shape?(color=red&(width>30));(sides<=12);(shape=square&(color!=black;user=bob))\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\nquery = inquire(inquire('color', 'red').and(inquire.gt('width', 30)))\r\n.or(inquire.lte('sides', 12))\r\n.or(inquire('shape', 'square').and(inquire.neq('color', 'black').or('user', 'bob')));\r\nurl = \"/api/shape/\" + query.generate();\r\n// url => /api/shape?(color=red&(width>30));(sides<=12);(shape=square&(color!=black;user=bob))\r\n```\r\n\r\nNote: At this time, inquire does not optimize away parens.\r\n\r\n## Usage\r\n\r\nThe inquire class can be used to create a new predicate defaulting to equality.\r\nThere are multiple ways to create an `inquire`.\r\n\r\nPassing just the key, value pair.\r\n\r\nLiveScript:\r\n\r\n```livescript\r\ninquire \\key, \\value #=> key=value\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\ninquire('key', 'value'); //=> key=value\r\n```\r\n\r\nPassing in another `inquire`, which will end up wrapping it in parens.\r\n\r\nLiveScript:\r\n\r\n```livescript\r\ninquire inquire \\key, \\value #=> (key=value)\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\ninquire(inquire('key', 'value')); //=> (key=value)\r\n```\r\nYou can pass in an object, or an array of `inquire`'s.\r\nBoth of these conjoin their values by default and wrap in parens.\r\n\r\nLiveScript:\r\n\r\n```livescript\r\ninquire {key1: \\value1, key2: \\value2} #=> (key1=value1&key2=value2)\r\ninquire [inquire(\\key1, \\value1), inquire(\\key2, \\value2)] #=> ((key1=value1)&(key2=value2))\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\ninquire({key1: 'value1', key2: 'value2'}); //=> (key1=value1&key2=value2)\r\ninquire([inquire('key1', 'value1'), inquire('key2', 'value2')]); //=> ((key1=value1)&(key2=value2))\r\n```\r\n\r\nYou can change the default relation by calling a different operator.\r\n\r\nLiveScript:\r\n\r\n```livescript\r\ninquire.gte \\key, \\value #=> key>=value\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\ninquire.gte('key', 'value'); //=> key>=value\r\n```\r\n\r\nThe `and` and `or` predicates work in much the same way,\r\nbut require an already created `inquire`.\r\n\r\nLiveScript:\r\n\r\n```livescript\r\ninquire \\key1, \\value1 .and \\key2, \\value2 #=> key1=value1&key2=value2\r\ninquire \\key1, \\value1 .or \\key2, \\value2 #=> key1=value1;key2=value2\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\ninquire('key1', 'value1').and('key2', 'value2'); //=> key1=value1&key2=value2\r\ninquire('key1', 'value1').or('key2', 'value2'); //=> key1=value1;key2=value2\r\n```\r\n\r\n`Inquire` supports three boolean operators `and`, `or`, and `not`.\r\nThese operators also take objects, arrays, and `inquire`'s.\r\nIn addition, `and` and `or` take `key`, `value` strings and construct the proper query.\r\nThe semantics for `and` and `or` are similar to the constructor taking these types,\r\nand conjoining or disjoining it to the previous `inquire` with the proper operator.\r\nFor `not`, the argument is analyzed then wrapped in parens and negated.\r\n\r\n__NOTE__: `not` doesn't take `key`, `value` strings.\r\nCurrently, this will produce a querystring, but it will not have the valid semantics.\r\nSomething like `!(key=undefined)`.\r\n\r\n\r\nLiveScript:\r\n\r\n```livescript\r\ninquire.not inquire \\key, \\value #=> !(key=value)\r\n```\r\n\r\nJavascript:\r\n\r\n```javascript\r\ninquire.not(inquire('key', 'value')) //=> !(key=value)\r\n```\r\n\r\n### Functions\r\n\r\n##### eq(key, val)\r\nCreates a `key=val` predicate.\r\n\r\n##### neq (key, val)\r\nCreates a `key!=val` predicate.\r\n\r\n##### gt (key, val)\r\nCreates a `key>val` predicate.\r\n\r\n##### gte (key, val)\r\nCreates a `key>=val` predicate.\r\n\r\n##### lt (key, val)\r\nCreates a `key<val` predicate.\r\n\r\n##### lte (key, val)\r\nCreates a `key<=val` predicate.\r\n\r\n##### and(key, val)\r\nIf `key` is an `inquire`, then it wraps the `inquire` in parens\r\nand conjoins it with the current `inquire`.\r\n\r\nOtherwise, assumes `key` is a string and `val` has a `toString` function,\r\nthen conjoins the current query with a new `key=val` predicate.\r\n\r\n##### or(key, val)\r\nIf `key` is an `inquire` then it wraps the `inquire` in parens\r\nand disjoins it with the current `inquire`.\r\n\r\nOtherwise, assumes `key` is a string and `val` has a `toString` function,\r\nthen disjoins the current query with a new `key=val` predicate.\r\n\r\n##### not(query)\r\nNegates the supplied query.\r\n\r\n##### generate()\r\nReturns a formatted querystring.\r\n\r\n##### parse(querystring)\r\nGenerates an inquire from the passed in query string.\r\n\r\n### Fantasy Land Algebras\r\n\r\n#### Semigroup\r\n\r\n##### concat(inquire)\r\nTakes an inquire and conjoins it to a copy of the current inquire with `and`.  This function is associative, meaning that no matter what kind of parens nesting you use to call `concat`, the result will always be the same.\r\nFor example, given some predicates `a`, `b`, `c` and `d` (each of the form `key=val`), `a.concat(b).concat(c.concat(d))` is equivalent to `a.concat(b.concat(c).concat(d))`.  To put it in more explicit terms, `(a&b)&(c&d)` is equivalent to `a&((b&c)&d)`\r\n\r\n#### Monoid\r\n\r\n##### empty()\r\nReturns an empty inquire.\r\nAlthough it might seem useless, this has its place when being used with other structures.  Much like the identity function has its place for functions, the number 1 its place for multiplication, or the number 0 its place for addition.\r\n\r\n#### Functor\r\n\r\n##### map(function)\r\nTakes the function and applies the inquire to it.  The inquire is first stringified then passed to the function, so the function should operate over strings.  The result of the function is then used to create a new inquire and returned.  The function can return whatever it wants, and inquire will try its best to make something of it, but realize that at this time only strings, arrays, objects, and other inquires are really supported.\r\n\r\n\r\n[armet]: http://armet.github.io/\r\n[inquire]: https://npmjs.org/package/inquire\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}